<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--><html class="no-js" prefix="og: http://ogp.me/ns#" xmlns:og="http://ogp.me/ns#"><!--<![endif]-->

    <head>
                <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="author" content="">
  
	
        <meta property="og:site_name" content="Staaldraad">
        <meta property="og:title" content="Staaldraad">
        <meta property="og:url" content="https://staaldraad.github.io/post/2018-03-16-quick-win-with-graphql/">
        <meta property="og:description" content="">
    
        <meta property="og:type" content="article" />
        <meta property="og:article:author" content="" />
        <meta property="og:article:published_time" content="2018-03-16T17:10:39Z" />
    
        <meta name="generator" content="Hugo 0.48" />
        <title>Quick win with GraphQL &middot; Staaldraad</title>
        <link rel="canonical" href="https://staaldraad.github.io/" />
        <link rel="alternate" type="application/rss+xml" title="RSS" href="">
        <link rel="stylesheet" type="text/css" href="https://staaldraad.github.io/css/main.css"/>
        <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300|Montserrat:700" rel="stylesheet" type="text/css">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
        <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
    </head>

<body>
<!--[if lt IE 7]><p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chrome/â€Ž">install Google Chrome</a> to experience this site.</p><![endif]-->

    <header id="site-header">
        <div class="container">
            <a href="https://staaldraad.github.io/" alt="Staaldraad"><h1 class="blog-title heading">Staaldraad</h1></a>
            
            <p class="blog-description"></p>
           
            <a href="https://twitter.com/_staaldraad"><span class="icon icon--twitter"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"></path></svg>
            </span><span class="username">_staaldraad</span></a>
            <br/>
            <a href="https://github.com/staaldraad"><span class="icon icon--github"><svg viewBox="0 0 16 16" width="16px" height="16px"><path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"></path></svg>
            </span><span class="username">staaldraad</span></a>
        </div>
    </header>
<main class="content" role="main">
	<div class="container">
		<article class="post">
	<header class="post-header">
        <h3 class="p-post-title">Quick win with GraphQL</h3>
        <p class="post-time"><time datetime="2018-03-16T17:10:39Z">March 16, 2018</time></p>
    </header>

    <section class="post-content">
        

<blockquote>
<p>&ldquo;GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data&rdquo; - <a href="http://graphql.org">graphql.org</a></p>
</blockquote>

<p>The GraphQL query language allows developers to easily write front-end queries, using a JSON like syntax, to retrieve data from the back-end. The big plus here that a single API end-point can return multiple types and formats of data based on the contents of the query.</p>

<p>This simplicity has resulted in a steady adaption of GraphQL. With this adoption, we as security testers need to understand GraphQL and how it can lead to unauthorised data access and modification. Over the last year there have been a few blog posts touching on GraphQL and exploitation of GraphQL end-points. These are recommended reading, but maybe wait until after reading this post. You&rsquo;ll understand why shortly.</p>

<ul>
<li><a href="http://www.petecorey.com/blog/2017/06/12/graphql-nosql-injection-through-json-types/">http://www.petecorey.com/blog/2017/06/12/graphql-nosql-injection-through-json-types/</a></li>
<li><a href="https://raz0r.name/articles/looting-graphql-endpoints-for-fun-and-profit/">https://raz0r.name/articles/looting-graphql-endpoints-for-fun-and-profit/</a></li>
<li><a href="https://labs.detectify.com/2018/03/14/graphql-abuse/">https://labs.detectify.com/2018/03/14/graphql-abuse/</a></li>
</ul>

<h2 id="graphql-basics">GraphQL Basics</h2>

<p>I&rsquo;m not going to go too deeply into GraphQL and how to interact with it, the above posts do an excellent job of this and I don&rsquo;t want to create duplicate work. The <a href="http://graphql.org/learn/queries">GraphQL documentation</a> is also a great resource and I highly recommend reading through this to get a better understanding of the underlying concepts.</p>

<p>The few basics I do want to touch on are:</p>

<ul>
<li>Schemas</li>
<li>Types</li>
<li>Fields</li>
<li>Arguments</li>
<li>Mutations</li>
</ul>

<p>Again, this is just a quick overview from my point of view, it is probably best that you read the official documentation to get a firm grasp on the concepts.</p>

<h3 id="schemas">Schemas</h3>

<p>When you interact with GraphQL you do so through the query language. Since this query language is providing an interface to your backend data, it needs a definition of how the data and queries should be structured. This is where the schema comes in, it simply contains the information about what queries are supported. This serves as a validation layer to ensure incoming queries are well formed and supported.</p>

<h3 id="types">Types</h3>

<p>Since GraphQL provides an interface to data, it needs a type system to define the different data-types that are supported. The supported types can be found <a href="https://labs.detectify.com/2018/03/14/graphql-abuse/">here</a>. Essentially you are looking at things scaler types such as <code>Int</code>, <code>String</code>, <code>Float</code>, <code>Boolean</code> and <code>ID</code>. And a few other types, <code>enum</code>, <code>lists</code>, <code>interfaces</code>.</p>

<h3 id="fields">Fields</h3>

<p>These are the actual data values that are available in a data Object. In any GraphQL query you will see fields, if you ask for a field, and it is defined in the schema, it will be return to you.</p>

<h3 id="arguments">Arguments</h3>

<p>Just like other query languages, GraphQL provides a mechanism for limiting the data that is returned. Arguments are used for this purpose and are defined in the schema. Here again GraphQL uses the schema to validate a given query, and set of arguments, before being passed to the API responsible for retrieving the relevant data. This forces strong typing and is just another mechanism that prevents injection attacks.</p>

<h3 id="mutations">Mutations</h3>

<p>Sometimes you don&rsquo;t want to query data, you want to modify it. This is where mutations come in. Mutations allow you to define the &ldquo;functions&rdquo; that can be executed through GraphQL, including the fields that are modified and the arguments that are allowed.</p>

<h2 id="introspection">Introspection</h2>

<p>This is where GraphQL gets really interesting, even more so if you are doing a security audit. GraphQL can be used to query itself, more specifically, the introspection system allows us to retrieve the full GraphQL schema. This is another piece of well <a href="http://graphql.org/learn/introspection/">documented information</a>, but not many web app testers seem to be aware of it.</p>

<p>Let&rsquo;s assume we have defined the following GraphQL schema:</p>

<pre><code class="language-json">type Account {
    id: String!
    name: Account
    active: Boolean!
}

type Query {
    getAccount(id: String!): Account
}
</code></pre>

<p>How do we do an introspection query? Using the exact same GraphQL end-point the API does of course! The most simple introspection query you could do is:</p>

<pre><code class="language-json">{
  __schema {
    types {
      name
    }
  }
}
</code></pre>

<p>What this does is query the <code>__schema</code> field, which is always available on the root type of a Query. We want the schema to return the field <code>name</code> from the field object <code>types</code>.</p>

<p>The results of the above query would be something along the lines of:</p>

<pre><code class="language-json">{
  &quot;data&quot;: {
    &quot;__schema&quot;: {
      &quot;types&quot;: [
        {
          &quot;name&quot;: &quot;Query&quot;
        },
        {
          &quot;name&quot;: &quot;Account&quot;
        },
        {
          &quot;name&quot;: &quot;ID&quot;
        },
        {
          &quot;name&quot;: &quot;String&quot;
        },
        {
          &quot;name&quot;: &quot;Int&quot;
        },
      .... &lt;SNIP&gt; ....
        {
          &quot;name&quot;: &quot;__DirectiveLocation&quot;
        }
      ]
    }
  }
}
</code></pre>

<p>This isn&rsquo;t all that helpful, right? No not really, what we need is to improve the introspection query to return more information. We want to know all about mutations, queries, fields, arguments etc. Fortunately for us there is <em>&ldquo;The introspection query to end all introspection queries&rdquo;</em>, which can be found in the the <a href="https://github.com/graphql/graphql-js/blob/master/src/utilities/introspectionQuery.js">GraphQL-JS repository</a>.</p>

<p>This query is available below:</p>

<script type="application/javascript" src="//gist.github.com/staaldraad/70ef19d1a32162182aaf4ac2b05327ad.js"></script>

<h2 id="attacking-with-introspection">Attacking with Introspection</h2>

<p>If we had to run the above query against a GraphQL end-point we would get an extremely useful response. The response is essentially a full API listing, and sometimes even includes helpful comments. This means we are able to see all the possible <code>queries</code> and <code>mutations</code> the GraphQL end-point can handle and we can start looking for flaws. The best thing about this is we get don&rsquo;t need any additional privileges and we have been able to map out all API end-points using a single request (no more missing an API request because you have the wrong user or didn&rsquo;t visit the correct page).</p>

<p>A useful example of this would be the end-point discussed in the <a href="https://labs.detectify.com/2018/03/14/graphql-abuse/">Detectify blog post</a> by Jon Bottarini (<a href="https://twitter.com/jon_bottarini">@jon_bottarini</a>), where he found the bug by comparing the GraphQL request for an Admin user versus that of a normal user. With introspection, we would be able to find all the <code>fields</code> that could be queried, even if we only had the normal user. It would still be up to us to test for missing authorisation checks, but we would have much better insight into the possible request that could be made.</p>

<p>Imagine we do the introspection query and get back the following result:</p>

<pre><code class="language-json">...&lt;SNIP&gt;...
 {
    &quot;possibleTypes&quot;: null,
    &quot;name&quot;: &quot;RootQueryType&quot;,
    &quot;kind&quot;: &quot;OBJECT&quot;,
    &quot;interfaces&quot;: [],
    &quot;inputFields&quot;: null,
    &quot;fields&quot;: [
        {
            &quot;type&quot;: {
                &quot;ofType&quot;: null,
                &quot;name&quot;: &quot;Account&quot;,
                &quot;kind&quot;: &quot;OBJECT&quot;
            },
            &quot;name&quot;: &quot;account&quot;,
            &quot;isDeprecated&quot;: false,
            &quot;description&quot;: null,
            &quot;deprecationReason&quot;: null,
            &quot;args&quot;: [
                {
                    &quot;type&quot;: {
                        &quot;ofType&quot;: {
                            &quot;ofType&quot;: null,
                            &quot;name&quot;: &quot;Int&quot;,
                            &quot;kind&quot;: &quot;SCALAR&quot;
                        },
                        &quot;name&quot;: null,
                        &quot;kind&quot;: &quot;NON_NULL&quot;
                    },
                    &quot;name&quot;: &quot;id&quot;,
                    &quot;description&quot;: null,
                    &quot;defaultValue&quot;: null
                }
            ]
        },
        {
            &quot;type&quot;: {
                &quot;ofType&quot;: null,
                &quot;name&quot;: &quot;User&quot;,
                &quot;kind&quot;: &quot;OBJECT&quot;
            },
            &quot;name&quot;: &quot;user&quot;,
            &quot;isDeprecated&quot;: false,
            &quot;description&quot;: null,
            &quot;deprecationReason&quot;: null,
            &quot;args&quot;: [
                {
                    &quot;type&quot;: {
                        &quot;ofType&quot;: null,
                        &quot;name&quot;: &quot;String&quot;,
                        &quot;kind&quot;: &quot;SCALAR&quot;
                    },
                    &quot;name&quot;: &quot;email&quot;,
                    &quot;description&quot;: null,
                    &quot;defaultValue&quot;: null
                },
                    {
                    &quot;type&quot;: {
                        &quot;ofType&quot;: null,
                        &quot;name&quot;: &quot;String&quot;,
                        &quot;kind&quot;: &quot;SCALAR&quot;
                    },
                    &quot;name&quot;: &quot;supersecret&quot;,
                    &quot;description&quot;: null,
                    &quot;defaultValue&quot;: null
                },
                {
                    &quot;type&quot;: {
                        &quot;ofType&quot;: null,
                        &quot;name&quot;: &quot;Int&quot;,
                        &quot;kind&quot;: &quot;SCALAR&quot;
                    },
                    &quot;name&quot;: &quot;id&quot;,
                    &quot;description&quot;: null,
                    &quot;defaultValue&quot;: null
                }
            ]
        },
...&lt;SNIP&gt;...
</code></pre>

<p>Firstly, we are looking at the available <code>query</code> types, since this is under the <strong>&ldquo;RootQueryType&rdquo;</strong>. In this snippet we have two queries, <code>account</code> and <code>user</code>. The <code>account</code> query is of kind <code>Object</code> and thus returns an <code>Account</code> object. The fields which can be queried are found  in<code>&quot;args&quot;</code> and is only the <code>id</code> field of type <code>Int</code>. Similarly the <code>user</code> query returns a <code>User</code> object and has the fields <code>email</code>, <code>supersecret</code> and <code>id</code>.</p>

<p>Now imagine we are doing a blackbox review and using the application we only ever see the following GraphQL request:</p>

<pre><code class="language-json">{
    user {
        id
        email
    }
}
</code></pre>

<p>We might never know that there is the third field <code>supersecret</code> unless we did the introspection query. With the information from the schema, we would know about <code>supersecret</code> and be able to get the value with:</p>

<pre><code class="language-json">{
    user {
        id
        email
        supersecret
    }
}
</code></pre>

<p>Similarly we can look through the schema to find all <code>mutation</code> types and then start investigating those for security issues (IDOR, authorisation checks etc).</p>

<pre><code class="language-json">{   &quot;possibleTypes&quot;: null,
        &quot;name&quot;: &quot;RootMutationType&quot;,
        &quot;kind&quot;: &quot;OBJECT&quot;,
        &quot;interfaces&quot;: [],
        &quot;inputFields&quot;: null,
        &quot;fields&quot;: [
            {
                &quot;type&quot;: {
                    &quot;ofType&quot;: null,
                    &quot;name&quot;: &quot;SecretKey&quot;,
                    &quot;kind&quot;: &quot;OBJECT&quot;
                },
                &quot;name&quot;: &quot;updateSecretKey&quot;,
                &quot;isDeprecated&quot;: false,
                &quot;description&quot;: &quot;Update the secret API key.&quot;,
                &quot;deprecationReason&quot;: null,
                &quot;args&quot;: [
                    {
                        &quot;type&quot;: {
                            &quot;ofType&quot;: {
                                &quot;ofType&quot;: null,
                                &quot;name&quot;: &quot;Int&quot;,
                                &quot;kind&quot;: &quot;SCALAR&quot;
                            },
                            &quot;name&quot;: null,
                            &quot;kind&quot;: &quot;NON_NULL&quot;
                        },
                        &quot;name&quot;: &quot;accountId&quot;,
                        &quot;description&quot;: &quot;The account ID of the user updating the key.&quot;,
                        &quot;defaultValue&quot;: null
                    },
                    {
                        &quot;type&quot;: {
                            &quot;ofType&quot;: {
                                &quot;ofType&quot;: null,
                                &quot;name&quot;: &quot;String&quot;,
                                &quot;kind&quot;: &quot;SCALAR&quot;
                            },
                            &quot;name&quot;: null,
                            &quot;kind&quot;: &quot;NON_NULL&quot;
                        },
                        &quot;name&quot;: &quot;secretKey&quot;,
                        &quot;description&quot;: &quot;The value of the new API key.&quot;,
                        &quot;defaultValue&quot;: null
                    }
                ]
            },

</code></pre>

<p>Here we have a <code>mutation</code> called <code>updateSecretKey</code> which takes two arguments; <code>accountId</code> and <code>apiKey</code>. We could now try invoke this through GraphQL with:</p>

<pre><code class="language-json">{
    mutation doUpdate() {
        updateSecretKey(accountId: 1234, secretKey: &quot;AAAA==&quot;) {
            secretkey
            lastupdated
        }
    }
}
</code></pre>

<p>This would try call our mutation, and update the <code>secretKey</code> for the <code>accountId</code> <code>1234</code>. And we want the <code>fields</code>, <code>secretkey</code> and <code>lastupdated</code> to be returned if the mutation was successful. These two fields are found in the definition of the <code>SecretKey</code> object in the schema, not shown here.</p>

<h2 id="turning-off-introspection">Turning off Introspection</h2>

<p>Introspection is built into the GraphQL language and I haven&rsquo;t found options to turn it off. What you could do is to use something like the third-party package, <a href="https://github.com/helfer/graphql-disable-introspection">graphql-disable-introspection</a>. This blocks introspection using  a simple validation rule. Queries that contain <code>__schema</code> or <code>__type</code> will fail validation with this rule.</p>

<p>That&rsquo;s that, nothing too fancy but a super useful way to quickly map out an attack surface through GraphQL. Maybe someone writes a &ldquo;schema to query&rdquo; converter to make this even easier. Hey, maybe I&rsquo;ll do it if I find some time. Happy pwnage!</p>

    </section>

    <hr>

    <footer class="post-footer">
        <section class="f-1">
            
            
            <p class="f-post-time"><time datetime="2018-03-16T17:10:39Z">March 16, 2018</time></p>
        </section>
                        
        <section class="f-2">
            <section class="share">
                <span>Share:
                <a class="icon-twitter" href="http://twitter.com/share?text=Quick%20win%20with%20GraphQL&url=https%3a%2f%2fstaaldraad.github.io%2fpost%2f2018-03-16-quick-win-with-graphql%2f"
                    onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
                    <i class="fa fa-twitter"></i>
                </a>
                <a class="icon-facebook" href="https://www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fstaaldraad.github.io%2fpost%2f2018-03-16-quick-win-with-graphql%2f"
                    onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
                    <i class="fa fa-facebook"></i>
                </a>
                <a class="icon-google-plus" href="https://plus.google.com/share?url=https%3a%2f%2fstaaldraad.github.io%2fpost%2f2018-03-16-quick-win-with-graphql%2f"
                   onclick="window.open(this.href, 'google-plus-share', 'width=490,height=530');return false;">
                    <i class="fa fa-google-plus"></i>
                </a>
                </span>
            </section>

            
        </section>
                        
    </footer>
</article>
	</div>
</main>
    <footer id="site-footer">
        <div class="container">
          
          
          
          
          <a href="https://staaldraad.github.io/index.xml" title="Get the RSS feed"><span class="tooltip"><i class="fa fa-rss"></i></span></a>
          <section>&copy; <a href="https://staaldraad.github.io/"></a> 2018 | All rights reserved</section>
          <section>Theme by <a href="http://www.jrdnbwmn.com">Jordan Bowman</a>. Generated with <a href="http://gohugo.io/">Hugo</a>.</section>
        </div>
    </footer>

    <script type="text/javascript" src="https://staaldraad.github.io/js/fittext.js"></script>
    <script type="text/javascript">
      $(".heading").fitText();
    </script>



</body>
</html>