<!DOCTYPE html>
<!--[if lt IE 7]><html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]><html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]><html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!--><html class="no-js" prefix="og: http://ogp.me/ns#" xmlns:og="http://ogp.me/ns#"><!--<![endif]-->

    <head>
                <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0" />
        <meta name="mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black">
        <meta name="author" content="">
  
	
        <meta property="og:site_name" content="Staaldraad">
        <meta property="og:title" content="Staaldraad">
        <meta property="og:url" content="https://staaldraad.github.io/">
        <meta property="og:description" content="">
    
        <meta property="og:type" content="website" />
    
        <meta name="generator" content="Hugo 0.31-DEV" />
        <title>Staaldraad &middot; Staaldraad</title>
        <link rel="canonical" href="https://staaldraad.github.io/" />
        <link rel="alternate" type="application/rss+xml" title="RSS" href="https://staaldraad.github.io/index.xml">
        <link rel="stylesheet" type="text/css" href="https://staaldraad.github.io/css/main.css"/>
        <link href="//fonts.googleapis.com/css?family=Source+Sans+Pro:300|Montserrat:700" rel="stylesheet" type="text/css">
        <link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">
        <script src="//code.jquery.com/jquery-1.10.2.min.js"></script>
    </head>

<body>
<!--[if lt IE 7]><p class="browsehappy">You are using an <strong>outdated</strong> browser. Please <a href="http://browsehappy.com/">upgrade your browser</a> or <a href="http://www.google.com/chrome/â€Ž">install Google Chrome</a> to experience this site.</p><![endif]-->

    <header id="site-header">
        <div class="container">
            <a href="https://staaldraad.github.io/" alt="Staaldraad"><h1 class="blog-title heading">Staaldraad</h1></a>
            <p class="blog-description"></p>
        </div>
    </header>
<main class="content" role="main">
	<div class="container">
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/post/2018-02-17-crossposts/">Cross Posting - Other Blog Posts</a></h3>
        <p class="post-time"><time datetime="2018-02-17T10:16:39Z">February 17, 2018</time></p>
    </header>
    
    <section class="post-excerpt">
        <p><p>Before creating this blog, I had the opportunity to posts numerous blogs under <a href="https://sensepost.com">SensePost</a>. These cover a few topics including mobile apps, web apps and infrastructure.

Here is a list of those posts, in chronological order, with a brief abstract about each post.</p></p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2017/12/20/netstat-without-netstat/">netstat without netstat</a></h3>
        <p class="post-time"><time datetime="2017-12-20T14:16:39Z">December 20, 2017</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>Recently I was doing an assessment in a locked down and restricted environment. One of the first actions you tend to do when landing a shell on a [linux] box is to do some reconnaissance. This is both on host and network, as you want to determine what new access this host has given you. Normally you would run netstat, ifconfig, ip route etc to determine if the compromised host is connected to any other hosts and to determine if there are other network segments you do not know about.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2017/11/12/polycom-hdx-rce/">Polycom HDX Series RCE</a></h3>
        <p class="post-time"><time datetime="2017-11-12T10:29:00Z">November 12, 2017</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>When doing external assessments you spend a decent amount of time footprinting your target and finding possible avenues of attack. Given a large corporate, you are pretty likely to hit video conferencing end-points. This post details a vulnerability in one of these video conferencing systems, the Polycom HDX series.
I identified this vulnerability while still at SensePost and reported it to Polycom. The vulnerability was acknowledged and we were informed that a patch would be issued.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2017/10/23/msword-field-codes/">MSWord - Obfuscation with Field Codes</a></h3>
        <p class="post-time"><time datetime="2017-10-23T15:14:39Z">October 23, 2017</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>A few weeks back Saif El-Sherei and I posted on the SensePost blog about DDE and getting command exec in MSWord without macros. This post got way more attention than we initially expected it would. Since then DDE has been used in phishing and malware campaigns, as well as legitimate red-team engagements. With the rapid rise in attacks using DDE, detection has been stepped up and most AV engines have basic DDE detection built in.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2017/08/02/o356-phishing-with-oauth/">Phishing with OAuth and o365/Azure</a></h3>
        <p class="post-time"><time datetime="2017-08-02T15:14:39Z">August 2, 2017</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>Typically phishing has provided a low tech approach to getting access to credentials and services. The mainfocus up until now has been on getting username&amp;passwords or tricking users into executing code. Subsequently, user awareness has gone up and users are better at identifying suspicious pages. Experience has shown that the click-through rate on emails have remained high, while users have been (slightly) less likely to enter credentials and more likely to report the phishing page.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2017/04/17/nat-to-nat-with-wireguard/">NAT-to-NAT VPN with WireGuard</a></h3>
        <p class="post-time"><time datetime="2017-04-17T13:14:39Z">April 17, 2017</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>A recent research project/idea required me to look into setting up a NAT-to-NAT VPN. The basic idea being that two NATed networks are able to communicate through a VPN and share resources. While researching possible VPN solutions, I remembered reading about WireGuard a new VPN that aims to be fast, secure and lightweight. This seemed like the perfect opportunity to both try out a new VPN implementation and accomplish the goals of the research project.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2016/12/11/xxeftp/">XXE FTP Server - A {web,ftp}-server for XXE</a></h3>
        <p class="post-time"><time datetime="2016-12-11T17:14:39Z">December 11, 2016</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>XXE - FTP OoB basics XXE offers a great attack avenue for reading files from a vulnerable web-app. One of my favourite XXE attacks involves protocol handler abuse, where you use FTP to do an out of band read. This is useful in those cases where you have XXE but it is blind. Unlike the normal OoB retreival through HTTP, FTP works with newer versions of Java (&gt;1.7) and there are fewer characters which break the retrieval.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2016/12/11/tcpprox/">tcpprox - An intercepting TCP proxy</a></h3>
        <p class="post-time"><time datetime="2016-12-11T16:14:39Z">December 11, 2016</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>On numerous occasions I&rsquo;ve run into custom binary network protocols that I&rsquo;ve wanted to reverse. The usual goto here is to fireup wireshark/tcpdump and view the traffic as it goes accross the wire. This works really well in most cases, but how about traffic that uses TLS to encrypt the traffic? Unless you have the private key for the server, you are stuck with viewing encrypted traffic in wireshark. Not ideal for reverse engineering.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2016/10/03/powershell-shells/">Powershell Shells</a></h3>
        <p class="post-time"><time datetime="2016-10-03T15:31:39Z">October 3, 2016</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>It&rsquo;s been a while&hellip; I figured it&rsquo;s about time I post something here again.
A while back I was required to see how much damage can be done by a malicious staff member. The one caveat here was that I had to test directly from the Windows box and had extremely limited outbound comms. For various reasons the usual tool-suites were out and I took this as a challenge to see how much damage I could do by coding tools on the &ldquo;employee machine&rdquo;.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
		<article class="li post">
    <header class="post-header">
        <h3 class="post-title"><a href="https://staaldraad.github.io/2015/09/10/proxy-for-websockets/">Viewing, modifying and replaying websockets</a></h3>
        <p class="post-time"><time datetime="2015-09-10T14:16:39Z">September 10, 2015</time></p>
    </header>
    
    <section class="post-excerpt">
        <p>A few assessments back I ran into a web app that made libral use of websockets. Now it&rsquo;s been a while since encountering an app that makes use of websockets for such a large portion of it&rsquo;s content and I&rsquo;d forgotten what a PITA it can be trying to intercept and replay websocket requests.
Seeing as it was a web app assessment I naturally turned to trusty Burp Suite Pro. Burp has supported websockets for a long while now, but far as I could find, this support only allowed you to intercept websocket requests and view/modify them.</p>
    </section>

    <footer class="post-footer">
        <span>
            
            
        </span>
    </footer>
</article>
	
	
<nav role="pagination" class="pagination">
  
	<span class="post-list-pagination-item post-list-pagination-item-current">Page 1 of 2</span>

  <a href="/page/2/" class="older-posts">
    &nbsp;Older&nbsp;<i class="fa fa-angle-double-right"></i>
  </a>

</nav>

	</div>
</main>
    <footer id="site-footer">
        <div class="container">
          
          
          
          
          <a href="https://staaldraad.github.io/index.xml" title="Get the RSS feed"><span class="tooltip"><i class="fa fa-rss"></i></span></a>
          <section>&copy; <a href="https://staaldraad.github.io/"></a> 2017 | All rights reserved</section>
          <section>Theme by <a href="http://www.jrdnbwmn.com">Jordan Bowman</a>. Generated with <a href="http://gohugo.io/">Hugo</a>.</section>
        </div>
    </footer>

    <script type="text/javascript" src="https://staaldraad.github.io/js/fittext.js"></script>
    <script type="text/javascript">
      $(".heading").fitText();
    </script>


</body>
</html>